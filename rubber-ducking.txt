I am sure I am going to regret some of this file structure lol 

ok so I can use some sample images to detect lying and other emotional intelligence questions based on pictures 
	I can probably get them by looking back as the Unanimous Paper on EQ (https://unanimous.ai/wp-content/uploads/2018/09/Amplifying-Social-Intelligence-IEEE-ai4i-2018.pdf)

let's try to update the rank of the questions based on their votes 
	this is the way you sort an array of objects by value (https://www.javascripttutorial.net/array/javascript-sort-an-array-of-objects/)
		I also checked that this works in the browser
	now I just have to do it in state 

now that I've hooked up Firebase (get it, "hooked" up ahahha), let's figure out the optimal JSON structure
	uhm, I guess I have not figured out how to update Firebase from the app lol 
	how do I update the rank of the questions
		I should probably just sort them by value
		wait, it's already there in the code! 
	maybe I should calculate the score by adding the scores from all participants
		Yea, that makes sense  

	firebase {
		combo {
			pictureA: "dogA_id",
			pictureB: "dogB_id",
			features: {
				"preset_feature_A": {
					"score": {
						0: 0
						1: .2
						2: .3
					}
					"weight": 12
				},
				"generated_feature_A": {
					"score": {
						0: 0
						1: .5
						2: .2
					}
					"weight": 11
				},
			}
		}
	}

let's see, how do I best leverage the onChange on the range input
	I should probably do this when I move everything to the new view
	Yea, bc new view --> table with the input 
	I should probably implement this rn and then just move the logic to the new view when I get to it
	hook + push the object on submit vs. update Firebase continously 
		The issue with updating Firebase right away is that I'd have to somehow track who voted for what 
			I guess I could use the push.key trick and save that into state and just update that key all the time
			{ "user_id": vote } vs { "key": {"user_id": vote } }


let's create the round robin system 
	the pic pair is going to be in the JSON already 
		I'm going to generate the base JSON with a python script
	
Ok the key now is to do a limited view change
	Thinking of holding a title in the middle and then rendering the other components invisible
	I wonder how the original Flock paper did this
		"Flock asks crowd members to guesswhich of two examples is from a positive class and which isfrom the negative class, then write a reason why. These rea-sons become features: Flock automatically clusters the rea-sons, then recruits crowds to normalize each cluster and pro-duce features. These features are then used by the crowd toannotate each example."
		"Flock trains multiple models with different fea-ture subsets. It does so to show the user the performance of multiple prediction methods on the test set. These models in-clude Crowd prediction(a baseline asking workers directlyto guess the correct label for the example), ML with off-the-shelf(the chosen machine learning model using only out-of-the-box features such as n-grams), ML with crowd(the cho-sen machine learning model using only crowd features), or Hybrid(the full Flock model using both machine and crowdfeatures)."
		"Previous research on analogical encoding has found thatwhen considering single examples, people tend to focus onsurface-level details, but when they compare examples, theyfocus on deeper structural characteristics"
		"Flock launches 100c omparison tasks with three workers each per dataset, result-ing in 300 nominated features for about six cents per label ($20 total)."
	Ah ok, so they have one task to generate features, and one task to vote on them
		They are two separate tasks
		"The features have considerable overlap, and manual cat-egorization suggested that the 300 nominations typically clus-tered into roughly 50 features."
		"First, the system splits each responseinto multiple suggestions (e.g. by sentence, newlines, andconjunctions such as “and”). The system then performsk-means clustering (k= 50) using tf-idf weighted bigram text4 features. With these clusters in hand, Flock launches anothertask to CrowdFlower showing workers one cluster at a timeand asking them to summarize each into a single represen-tative question (or feature) that has a yes or no answer (e.g.,“Is this person shifting their eyes a lot?”). Three candidatefeatures are generated for each cluster."

MapReduced version
	Feature Generation 
		Should we do 2 different dogs and 1 that is similar to at least one of them? 
		Similarity + Difference
			Ask about similarities 
			Ask about differences 
		Cluster
			Basic n-gram stuff 
		Extract top 3 summary features 
	Feature Evaluation
		Rank is individual 
		Scoring is continous 

ok so let's figure out the sequence to pull of the rewrite
	I need to probably make separate pages, so that each link links to a different task 
	the features generated don't need to be linked by users 
		they can be just a part of JSON, a separte child
	then from that child I build a page where it shows the n-gram and the user submist the summary 
		the summary features need to be binary 
		then voting happens, which is how the top 3 gets selected
			which means I have to save this per user, or at least find a way to maintain the voting
				I can just not show current votes to the user and have them vote without registering who they are
		the summaries are saved on a new child 
	after clustering, I move on to the feature evalution 
		both rank and scoring need to be attached to an individual user 

ok so let's structure this DB
	firebase {
		suggestions: {
			idA: "suggestion from user A",
			idB: "suggestion from user B"
		},
		clusters: {
			clusterA: {
				suggestions: [ngramA, ngramB],
				summaries: {
					summary_id_1 {
						id_a: "summarizing cluster A",
						vote: 0
					},
					summary_id_2 {
						id_a: "summarizing cluster A",
						vote: 0
					}
				}

			}
		},
		combo {
			pictureA: "dogA_id",
			pictureB: "dogB_id",
			features: {
				"summary_id_1": {
					"score": {
						0: 0
						1: .2
						2: .3
					}
					"weight": {
						0: 0
						1: .2
						2: .3
					}
				},
				"summary_id_2": {
					"score": {
						0: 0
						1: .5
						2: .2
					}
					"weight": {
						0: 0
						1: .2
						2: .3
					}
				},
			}
		}
	}

ok so I'm at the suggestions page
	I already implemented the form to submit the suggestion, now I just have to do voting
	I can probably re-implement the logic from the v1
	The voting here though is not attached to the user, it's more like a usual upvote/downvote mechanism
		This means I need to add a "votes" value-key pair to each suggestion child
	I keep thinking that I should have separate phases for submitting and voting
		I am so dumb lol
		I already implemented this!!
	Why is it not updating?
		bc I was sorting the snapshots as opposed to the actual object
	Now I just need to limit the voting to just once per item
		I can disable the button for that vote
		how do I do this without having to set up a hook or a global property
		boom!

now I let's do the eval page
	mostly it's the same as the v1, just removing the option
	ok so I probalby don't need to change that much logic, bc I can set up the features to be evaluted based on teh results from the summary task 
		I'll automate this some day 
	ok so assume you already have the right features for each pair of dog pictures, what do you need to change? 
		both rank and scoring need to be attached to each user
	do I want to structure the data to be feature centric by having user-identified updates to the children of the feature? 
		Or do I want to make it user centric? 
		well, at a basic level it'd make it a lot easier to have this be pair centric to build the graph afterwards 
	uhm, so when the user submits, they are submitting a score and a rank 
		obviously score comes first, replicating the staging process that we have in the summary task 
		so all I need to do is restructure "weight" to be like "score" and similarly attach the value to the user-id
			the order somewhat doesn't matter as long as I have the id
	gosh, wouldn't be great if this was a carosel type thing
		#scope-creep
	ok so now even the next function operates properly

ok so let's see, where am I now? 
	I have to create a closing tastement for every task
		That's not too bad, especially bc I need to start with task 1

What do I have left
	change the summary page to focus on clusters
	closing statement for every task

TO-DO sidenote
	make the n-gram clustering automatic 
	select top 3 features from summaries automatically
	build the graph automatically (?)
	might be good to have a survey at the end
	let's not forget about the crypto mining in the background






